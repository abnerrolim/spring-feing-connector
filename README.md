# Spring Feign Connector

This lib provides a standardized way to declare a feign interface to our REST's API, providing the follows features:
* A standardized way to log and handle errors
* Always logs (info to success, error to FeingExceptions) your Request and Response with customized module name.
* Allows by configuration obfuscate the logs above, providing a configurable obfuscation for json fields, path params and headers.
* Allows to extract the current controller API to a common interface to be shared with feign clients without break any current integration.
* Standardized error return but with extensible metadata.
* Allow dynamic host resolution to your client when your API host depends of context configuration (eg: configurable multitenancy API)
# Table of contents
1. [When use it](#when)
2. [How configure](#howconfig)
3. [Basics](#basics)
4. [Migrating an Existing Controller to a Common Interface](#migratingcontroller)
	1. [Configuration of Your Feign Client](#configcontroller)
5. [Declaring Only Feign Interface](#migratinginterface)
	1. [Configuration of Your Feign Client](#configinterface)
6. [Advanced Configurations](#advanced)
	1. [Getting Feing.Builder from FeignConnectorConfigHelper](#feingbuilder)
	2. [Setting a different Jackson ObjectMapper](#objectmapper)
	3. [Configuring Log Obfuscator](#obfuscator)
	4. [Configuring Host Dynamic Resolution](#dynamicresolver)
7. [Using Your New Client](#clientuse)

## When use it<a name="when"></a>
* You have empty or json objects returns for your API. Other formats will be not fully supported.
* You have or want a standard error output: code and message to business errors and a map of lists of errors caused by field validations.
* You want to reduce boilerplated code dealing with feing integrations in your micro-service environment. 

## Basics<a name="basics"></a>
This lib configure defaults Decoder and ErrorDecoder allowing insert logs and obfuscation to that logs. 
The decoder is pretty simple and extends ResponseEntityDecoder which allows use spring ResponseEntity as response in your API.
The errorDecoder always try to bind the ErrorResponse class to the response. ErrorResponse class is the standard error response to this lib and expects tow kinds of message as response:
```json
{
  "code" : "ERR-01",
  "message" : "User is inactive"
}
```
```json
{
   "fields": {
      "age": [
         "Invalid age to drink beer."
      ],
      "billingAddress.street": [
         "mandatory field"
      ]
   }
}
```
The first message is used to business errors and the second one to bad request validations.

To allow more flexibility in ErrorResponse, all extra fields on json response will be setted as key-value map called metadata. The key will be the field name and the value will be a raw type or a LinkedHadhMap to objects (Jackson Strategy to deserialize Objects). So you can return more information if needed, but in other hand your client need to know how extract it.

If the bind fails, another ErrorResponse object will be created using the prefix configuration plus http status as code and a default message. So any exception is catched and will result in a valid error response and all process will be logged.

If you want to avoid the boilerplate code of try{..}catch(FeingException e){..} in your service, you can use ClientResponse in a more functional way. The ClientResponse.of accepts a Supplier<T> and will catch any ClientResponseException (the FeignException throwed by this lib). ClientResponse is a "Either like",
so you can apply the fold method to route errors and success, extract the status using isError(), isBadRequest, isNotFound, getHttpStatus (only errors) or getting directly the result using get (success) or error(error). See more in [Using Your New Client](#clientuse)
<blockquote style="background-color:#FFFEAC; color:black">NOTE: the get or getError method can throw NoSuchElementException when you are accessing the wrong state (error on success and vice-versa)</blockquote>
<blockquote style="background-color:#FFFEAC; color:black">NOTE: as you can see, ClientResponse accept a generic supplier. If you pass other supliers that aren't feign API calls generated by FeignConnectorConfigHelper, errors will not handled by the configurated ClientResponseErrorDecoder and any exception can be throwed, invalidating the use of ClientResponse.</blockquote>

## How configure<a name="howconfig"></a>
Since this lib is not in maven repos, you need to import by hand in your repository. 
```xml
<dependency>
	<groupId>br.org.abnerrolim</groupId>
    <artifactId>spring-feign-connector</artifactId>
    <version>1.0.0-SNAPSHOT</version>
</dependency>
```

Now declare the follows configurations at your application.properties. You can configure the best values to fit in your project
```properties
feign.connect.timeout=10000
feign.read.timeout=50000
#Module name customization to better identify your log.
realwave.feing.module.client.name="Coffe Table Module"
#Module name error prefix to build unmapped error messages, such 500, 404, etc.
realwave.feing.module.client.error.prefix="COFF"
```

Make the package ```br.com.zup.realwave.fc.feign``` scannable in your Spring Boot Configuration class. Ex:
```java
@ComponentScan({"br.org.abnerrolim.spring.feign.connector",
...})
@Configuration
@Import(TrackingConfig.class)
public class ExternalWalletConfig extends WebMvcConfigurerAdapter {

}
```

Add this package into your log4j2.xml
```xml
<Logger name="br.org.abnerrolim.spring.feign.connector" level="DEBUG" additivity="false">
	<AppenderRef ref="Console"/>
</Logger>
```

## Migrating an Existing Controller to a Common Interface<a name="migratingcontroller"></a>
To use the same Feign interface to map your API implementation as your feign client you need to do as follow:
> Note that you will add interdependence between API and client

First, you need to extract your methods and spring REST mappings to a interface.So supposing that you have this controller implementation:
```java
/*
* Controller with the success response
 */
@RestController
public class WalletController {
    @RequestMapping(method = RequestMethod.POST, value = "/v1/credit-cards", consumes = MediaType.APPLICATION_JSON_VALUE)
    public WalletCreditCardAdded createCreditCard(@Valid @RequestBody AddCreditCard addCreditCard){
        return doStuffs(externalWalletAddCreditCard);
    }
}
/*
* Bad Requests will be handler automatically by spring and return a fields object
*/
```
You need to extract for a common interface
```java
    public interface CreditCardService {
    @RequestMapping(method = RequestMethod.POST, value = "/v1/credit-cards", consumes = MediaType.APPLICATION_JSON_VALUE)
    ResponseEntity<WalletCreditCardAdded> createCreditCard(@Valid @RequestBody AddCreditCard addCreditCard);
}
```
> Note that you still using the spring annotations for that.

With this new interface, you need to implements in your controller, removing annotations.

```java
@RestController
public class WalletController  implements CreditCardService {

   @Override
   public ResponseEntity<WalletCreditCardAdded> createCreditCard(@Valid @RequestBody AddCreditCard addCreditCard){
        return doStuffs(externalWalletAddCreditCard);
    }
}
```
### Configuration of Your Feign Client<a name="configcontroller"></a>
Now you have the same contract about your API implementation and Feign clients, so is a good idea put this commons objects of requests and response also the interface itself into a separated lib, to be imported for your API's future customers. Also can be a good idea provides a default class to construct your Feign bean client at runtime. It is not mandatory, since it can be done by the project that will use your API, but it is high recommended at least provide a documentation of minimal requirements about how configure your Feign.Builder, because you supposedly have more knowledge about the needs of obfuscation, json object mappers and so. This lib provides a helper to build clients with correctly configurations easily, but allows you to customize the builder if you want.

Using as example this previous API, here is how you can configure your Feign bean. Others ways to configure your feign builder will be showed later as advanced configuration.
```java
@Configuration
public class ExternalWalletConnectorConfig {

    @Bean
    public CreditCardService creditCardService(@Value("${wallet.rest.query.url}") String walletQueryUrl
                                               SomeImportantFeignInterceptor feignInterceptor,
                                               FeignConnectorConfigHelper feignConnectorConfigHelper) {

		//obfuscate request and response logged (see about obfuscation topic)
        HttpObfuscator obfuscator = ConfigurableHttpObfuscator.builder()
                .jsonBodyFields("pan", "cardToken", "cvv")
                .pathSegments(Arrays.asList("/cards/${obfuscate}"))
                .build();
                
        return feignConnectorConfigHelper.config()
                .withSpringContract() //mandatory if you use spring annotations to share the same interface with controllers
                .withObfuscator(obfuscator)
                .withRequestInterceptor(new MyInterceptorHere(), feignInterceptor) //Business interceptors
                .buildSimpleClient(CreditCardService.class, walletQueryUrl);
    }
}
```
## Declaring Only Feign Interface<a name="migratinginterface"></a>
Sometimes your application doesn't need or can't have a common interface either because you don't want be coupled with your client implementation or because your return type is not compatible with spring Feign limitations, like async returns. In that case, using this lib is a lot easy, because you don't have to do any modification in your controller.

The first step is declaring a interface with the same controller's signature. You can use default Feign annotations here, since your controller will not extends this interface. Using the same example, an interface would be like this:
```java
    public interface CreditCardService {
    
	@RequestLine("POST /v1/credit-cards")
    @Headers({"Content-Type: application/json"})
    ClientResponse<WalletCreditCardAdded> createCreditCard(@Valid AddCreditCard addCreditCard);
}
```
### Configuration of Your Feign Client<a name="configinterface"></a>
Same as migrating existing controller, is a good idea export your models and REST interface to a lib alone, allowing import only this lib to other client's projects  of your API. A configuration of Feign client in this case will be a lot more simple:
```java

@Configuration
public class ExternalWalletConnectorConfig {

    @Bean
    public CreditCardService creditCardService(@Value("${wallet.rest.query.url}") String walletQueryUrl
                                               SomeImportantFeignInterceptor feignInterceptor,
                                               FeignConnectorConfigHelper feignConnectorConfigHelper) {

		//If you don't need/wanna obfuscate, you can ignore withObfuscator config.
        // If you are using defaults feign annotations in your client, you can drop the withSpringContract configs too
        return feignConnectorConfigHelper.config()
                .withRequestInterceptor(new MyInterceptorHere(), feignInterceptor) //Business interceptors
                .buildSimpleClient(CreditCardService.class, walletQueryUrl);
    }
}
```

## Advanced Configurations<a name="advanced"></a>

### Getting Feing.Builder from FeignConnectorConfigHelper<a name="feingbuilder"></a>
You always can overwrite or extends the default configurations of Feing.Builder using FeignConnectorConfigHelper:
```java
    @Bean
    public CreditCardService creditCardService(SomeImportantFeignInterceptor feignInterceptor,
                                               FeignConnectorConfigHelper feignConnectorConfigHelper) {

        
        Feign.Builder builder = feignConnectorConfigHelper.config()
                .withSpringContract()
                .withRequestInterceptor(new MyInterceptorHere(), feignInterceptor)
                .feignBuilder();
        
        return builder.decode404()
                .target(CreditCardService.class, "http://myservice.com/api");
    }
```
Of course if you override decoders, etc. the lib will not runs as desired, lib's decoder and errordecoder are the core of all the features so use this only if you need customize some specific Feign behavior.

### Setting a different Jackson ObjectMapper<a name="objectmapper"></a>
If you need a specific ObjectMapper's config to parse your objects you can override the default one. But at least check the current default configurations to avoid some bizarre unmapped behavior, adding in your ObjectMapper most of defaults options.
```java
    @Bean
    public CreditCardService creditCardService(@Value("${wallet.rest.query.url}") String walletQueryUrl,
                                               SomeImportantFeignInterceptor feignInterceptor,
                                               FeignConnectorConfigHelper feignConnectorConfigHelper) {
        ObjectMapper objectMapper = new ObjectMapper();
        /*these are the default configs of this lib.
        so with you want these options, you don't need to config ObjectMapper, just use
        feignConnectorConfigHelper.config()
         */
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.registerModule(new Jdk8Module());
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        objectMapper.configure(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false);
        objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ"));
        objectMapper.setTimeZone(TimeZone.getTimeZone("UTC"));
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);

        return feignConnectorConfigHelper.config(objectMapper)
                .withSpringContract()
                .withRequestInterceptor(new MyInterceptorHere(), feignInterceptor)
                .buildSimpleClient(CreditCardService.class, walletQueryUrl);;
    }
```

### Configuring Log Obfuscator<a name="obfuscator"></a>
Requests and responses always will be logged by decoders (at least if you not overwrite decoders). Error responses will be logged with error level and successful responses as info level. If you don't want log all informations about requests and responses you can configure a obfuscator to hide secret infos. You can hide headers, specific json fields and path params with ConfigurableHttpObfuscator.

#### Json fields
All fields of json objects to be obfuscated of requests and responses in your API needs to be declared since the same HttpObfuscator will be used to all API methods. As example, assumes that you have the follow API:
```java
    @RequestMapping(method = RequestMethod.POST, value = "/v1/credit-cards", consumes = MediaType.APPLICATION_JSON_VALUE)
    CreditCardAdded createCreditCard(@Valid @RequestBody AddCreditCard addCreditCard);

    @RequestMapping(method = RequestMethod.POST, value = "/v1/credit-cards/{externalId}", consumes = MediaType.APPLICATION_JSON_VALUE)
    void updateCreditCard(@Valid @RequestBody UpdateCreditCard updateCreditCard, @PathVariable("externalId") String externalId);

```
And your entities are:
```java
@Data
public class AddCreditCard{
	private String holder;
	private Address billingAddress;
	private String creditCardNumber;
	private String cvv;
}
@Data
public class Address{
	private String street;
	private String postalCode;
}
@Data
public class CreditCardAdded{
	private String externalId;
}
@Data
public class UpdateCreditCard{
	private String holder;
	private Address billingAddress;
    private Address secondaryAddress;
}
```
And your HttpObfuscator is configured declaring full path of any desired field:
```java
HttpObfuscator obfuscator = ConfigurableHttpObfuscator.builder()
                .jsonBodyFields("holder", "creditCardNumber", "cvv", "billingAddress.street", "externalId")
                .build();
```
Will result in obfuscation of the follows fields:

* **AddCreditCard**: holder, creditCardNumber, cvv, street field on billingAddress object.
* **CreditCardAdded**: externalId
* **UpdateCreditCard**: holder,  street field on billingAddress object (but not in secondaryAddress object);

**Note About Limitations**
> Only Json Objects (ObjectNode to be more precisely) will be processed by Obfuscator. Collections will be not obfuscated at this version
#### Headers
You just need to declare the desired header key name to make it obfuscated. Despite of http spec says that Headers name are case insensitive, on Feign http headers are stored as Map, so "X-application" and "x-application" aren't the same and you would need to declare both.
#### Path Segments
You can hide specific params of your path, like id references and so on. You only need to make a template of your URL path using ${obfuscate} at params that you want obfuscate and ${value} where you don't.
As example, suppose that you want to hide  the path param {externalId} of updateCreditCard method declared before:
```java
HttpObfuscator obfuscator = ConfigurableHttpObfuscator.builder()
                .pathSegments(Arrays.asList("/v1/credit-cards/${obfuscate}"))
                .build();
```

Another example: to obfuscate the CPF number of client with this REST Mapping ```/v1/customer/{cpf}/book/ref/{bookref}``` the template will be ```/v1/customer/${obfuscate}/book/ref/${value}``` and a call with ```/v1/customer/111111111111/book/ref/Ead1230as``` will result on ```/v1/customer/************/book/ref/Ead1230as``` logged URL.

#### Finally Gluing Together
The final configurations of our ConfigurableHttpObfuscator will be like that:
```java
HttpObfuscator obfuscator = ConfigurableHttpObfuscator.builder()
                .jsonBodyFields("holder", "creditCardNumber", "cvv", "billingAddress.street", "externalId")
                .headers("Authorization", "X-Application-Key")
                .pathSegments(Arrays.asList("/v1/credit-cards/${obfuscate}"))
                .build();
```
And the follow original request to updateCreditCard method:
```
POST http://localhost:8882/v1/credit-cards/01f85d071a92b1415ce7b8 HTTP/1.1
Content-Length: 1691
Authorization: Bearer someBarearToken
X-Application-Key: Da09uqueajd093i2oi3jlkajsdlasd0923lLSDLA
Content-Type: application/json

{"holder":"Jordan Cardoso", "billingAddress":{"street":"Any Street","postalCode":"03092-2393"},"secondaryAddress":{"street":"Other Street","postalCode":"03092-2393"}}
```
Will be logged as:
```
INFO  ClientResponseDecoder - Wallet Command Module - Request was [
POST http://localhost:8882/v1/credit-cards/********************** HTTP/1.1
Content-Length: 1691
Authorization: ***************************
X-Application-Key: ****************************************
Content-Type: application/json

{"holder":"**************", "billingAddress":{"street":"**********","postalCode":"03092-2393"},"secondaryAddress":{"street":"Other Street","postalCode":"03092-2393"}}]. 
Response was [HTTP/1.1 200 OK
cache-control: no-cache, no-stage, must-revalidate
content-type: application/json
date: Tue Feb 20 19:16:24 GMT 2018
expires: Thu, 01 Jan 1970 00:00:00 GMT
pragma: no-cache
server: stubby4j/5.0.0 (HTTP stub server)
transfer-encoding: chunked
x-powered-by: Jetty(9.4.z-SNAPSHOT)
x-stubby-resource-id: 24
]
```
### Configuring Host Dynamic Resolution<a name="dynamicresolver"></a>
Sometimes is necessary resolve your host address of your Feign client at runtime. The most used way to do that is declaring an URL param into your Feign client's interface that is passed when the client method is invoked, like the example below:
```java
    @RequestLine("POST /payments")
    @Headers({"Content-Type: application/json"})
    AuthorizationResponse authorize(URI var1, AuthorizationRequest var2);
```
But this modified signature blocks the possibility to share the same interface with Spring Boot Controllers. To to that you can build your client using FeignConnectorConfigHelper using a Dynamic Resolver that receives a DynamicHostResolver implementation. This implementation will be responsible to resolve the host string by overriding ```String getHost()``` method. You can retrieve this value from database, properties or whatever you want. This host resolution will be concatenated with path mapped into Feign interface at runtime, so make sure to return a valid value.

## Using Your New Client<a name="clientuse"></a>
If you are ready to use a Feign interface builded with this approach, you only need to inject the interface (CreditCardService in this example). If the lib already defines a default bean injetor for CreditCardService that's it, your bean will be already injected with right configurations, but if not, see previous topics "Configuration of Your Feign Client" and ask to the author about the right configuration aspects.

Once the bean injector as defined, you need to ensure that error responses will be catch by your connector on proper way. The best way to do this is wrapping by a try-catch block like this:
```java
@AutoWired
CreditCardService creditCardService;
...
  ...
public WalletCreditCardAdded create(AddCreditCard addCreditCard){
	try{
		return creditCardService.createCreditCard(addCreditCard);
	}catch(ClientResponseErrorDecoder.ClientResponseException e){
	    //do some inteligent stuff with errors. Remember that the response is already logged
	    if(e.isBadRequest()){
	        throw ContractExpcetion(e.response.message);
	    }
    	throw e;
	}
}
```
Or a more functional approach with ClientResponse so in your business class you can use fold method of ClientResponse to route
```java
@AutoWired
CreditCardService creditCardService;
  ...
ClientResponse.of(() -> creditCardService.createCreditCard(addCreditCard)).fold(
  error -> doSomethingMagin(error),
  success -> doExpected(success)      
);

```

If you need to known which kind of http error was returned to made some strategy to automatically recover or things like that, you can find some easy methods on ClientResponse:
* getHttpStatus: will return the decoded http status from response if your client could execute a request with response. If the exception is not generated by default ErrorDecoder, this value can be null. This value is null on case of successful.
* error(): get the left projection ErrorResponse, if exists. If not will throws NoSuchElementException
* hasError: true if is error. Even if the response error isn't binded by standard fields, the ErrorDecoder will build an unmapped error, so code and message will never be null when a response error returns.
* isBadRequest: if is badrequest error response
* isNotFound: if is a not found error response
* get: returns success response object. Throws NoSuchElementException if is an error response.
* fold: Like Either fold method, executes left or right functions depending on the result type (error or success).
